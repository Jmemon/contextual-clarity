{
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "bash -c '#!/bin/bash\n# Fuel Hook - Auto-generated\n# Claude Code SessionStart hook\n# Captures session start events and writes to Fuel event queue\n\n# Event directories\nFUEL_EVENTS_BASE=\"${FUEL_EVENTS_DIR:-$HOME/.fuel/events}\"\nFUEL_EVENTS_NEW=\"$FUEL_EVENTS_BASE/new\"\nFUEL_LOGS_DIR=\"$HOME/.fuel/logs\"\nHOOK_LOG=\"$FUEL_LOGS_DIR/hooks.log\"\n\n# Ensure directories exist\nmkdir -p \"$FUEL_EVENTS_NEW\" 2>/dev/null\nmkdir -p \"$FUEL_LOGS_DIR\" 2>/dev/null\n\n# Read hook input from stdin (JSON format from Claude Code)\n# Expected format: {\"session_id\": \"...\", \"transcript_path\": \"...\", \"source\": \"...\", \"hook_event_name\": \"SessionStart\"}\nHOOK_INPUT=$(cat)\n\n# Extract fields using jq (with fallback to grep/sed if jq not available)\nif command -v jq >/dev/null 2>&1; then\n    SESSION_ID=$(echo \"$HOOK_INPUT\" | jq -r '\\''.session_id // empty'\\'')\n    TRANSCRIPT_PATH=$(echo \"$HOOK_INPUT\" | jq -r '\\''.transcript_path // empty'\\'')\n    SOURCE=$(echo \"$HOOK_INPUT\" | jq -r '\\''.source // \"unknown\"'\\'')\nelse\n    # Fallback: basic grep/sed parsing (less robust but works without jq)\n    SESSION_ID=$(echo \"$HOOK_INPUT\" | grep -o '\\''\"session_id\"[[:space:]]*:[[:space:]]*\"[^\"]*\"'\\'' | sed '\\''s/.*\"session_id\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/'\\'')\n    TRANSCRIPT_PATH=$(echo \"$HOOK_INPUT\" | grep -o '\\''\"transcript_path\"[[:space:]]*:[[:space:]]*\"[^\"]*\"'\\'' | sed '\\''s/.*\"transcript_path\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/'\\'')\n    SOURCE=$(echo \"$HOOK_INPUT\" | grep -o '\\''\"source\"[[:space:]]*:[[:space:]]*\"[^\"]*\"'\\'' | sed '\\''s/.*\"source\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/'\\'')\n    [ -z \"$SOURCE\" ] && SOURCE=\"unknown\"\nfi\n\n# Get current working directory for event details\nCWD=$(pwd)\n\n# Get main repository root for registry lookup\n# Use git worktree list to get main worktree path (first worktree is always main)\n# This works correctly in both main repo and linked worktrees\nREPO_ROOT=$(git worktree list --porcelain 2>/dev/null | grep \"^worktree \" | head -1 | cut -d'\\'' '\\'' -f2)\n\n# If git worktree fails, try git rev-parse as fallback\nif [ -z \"$REPO_ROOT\" ]; then\n    REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)\nfi\n\n# If both git commands fail, fall back to pwd -P (handles non-git directories gracefully)\nif [ -z \"$REPO_ROOT\" ]; then\n    REPO_ROOT=$(pwd -P 2>/dev/null || pwd)\nfi\n\n# Debug logging to help troubleshoot hook execution\necho \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] SessionStart hook: CWD=$CWD, REPO_ROOT=$REPO_ROOT\" >> \"$HOOK_LOG\"\n\n# Read connected repos registry to find repo_id\nREGISTRY_FILE=\"$HOME/.fuel/connected-repos.json\"\n\nif [ ! -f \"$REGISTRY_FILE\" ]; then\n    echo \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] Error: connected-repos.json not found at $REGISTRY_FILE\" >> \"$HOOK_LOG\"\n    exit 0\nfi\n\n# Find repo_id by matching repository root with repo_path in registry\nif command -v jq >/dev/null 2>&1; then\n    REPO_ID=$(jq -r --arg repo \"$REPO_ROOT\" '\\''.[] | select(.repo_path == $repo) | .id'\\'' \"$REGISTRY_FILE\")\nelse\n    # Fallback without jq (less robust)\n    # Note: In array format, id comes BEFORE repo_path, so we need to search differently\n    REPO_ID=$(grep -B5 \"\\\"repo_path\\\"[[:space:]]*:[[:space:]]*\\\"$REPO_ROOT\\\"\" \"$REGISTRY_FILE\" | grep '\\''\"id\"'\\'' | head -1 | sed '\\''s/.*\"id\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/'\\'')\nfi\n\nif [ -z \"$REPO_ID\" ] || [ \"$REPO_ID\" = \"null\" ]; then\n    echo \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] Warning: Repository not in connected repos: $REPO_ROOT\" >> \"$HOOK_LOG\"\n    exit 0\nfi\n\necho \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] Found repo_id: $REPO_ID for $REPO_ROOT\" >> \"$HOOK_LOG\"\n\n# Generate unique event filename with session_id for easy tracking\n# Format: claude_code_session_start_<timestamp>_<session_id>.json\nEVENT_FILE=\"$FUEL_EVENTS_NEW/claude_code_session_start_$(date +%s)_${SESSION_ID}.json\"\n\n# Write event file\ncat > \"$EVENT_FILE\" <<EOF\n{\n  \"type\": \"claude_code_session_start\",\n  \"timestamp\": \"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\",\n  \"details\": {\n    \"session_id\": \"$SESSION_ID\",\n    \"transcript_path\": \"$TRANSCRIPT_PATH\",\n    \"source\": \"$SOURCE\",\n    \"repo_id\": \"$REPO_ID\",\n    \"cwd\": \"$CWD\"\n  }\n}\nEOF\n\nif [ $? -ne 0 ]; then\n    echo \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] Error: Failed to write event file: $EVENT_FILE\" >> \"$HOOK_LOG\"\nfi\n\n# Always exit 0 to not block Claude Code\nexit 0\n'"
          }
        ]
      }
    ],
    "SessionEnd": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "bash -c '#!/bin/bash\n# Fuel Hook - Auto-generated\n# Claude Code SessionEnd hook\n# Copies transcript and writes session end event to Fuel event queue\n\n# Event and transcript directories\nFUEL_EVENTS_BASE=\"${FUEL_EVENTS_DIR:-$HOME/.fuel/events}\"\nFUEL_EVENTS_NEW=\"$FUEL_EVENTS_BASE/new\"\nTRANSCRIPTS_DIR=\"$HOME/.fuel/transcripts\"\nFUEL_LOGS_DIR=\"$HOME/.fuel/logs\"\nHOOK_LOG=\"$FUEL_LOGS_DIR/hooks.log\"\n\n# Ensure directories exist\nmkdir -p \"$FUEL_EVENTS_NEW\" 2>/dev/null\nmkdir -p \"$TRANSCRIPTS_DIR\" 2>/dev/null\nmkdir -p \"$FUEL_LOGS_DIR\" 2>/dev/null\n\n# Read hook input from stdin (JSON format from Claude Code)\n# Expected format: {\"session_id\": \"...\", \"transcript_path\": \"...\", \"cwd\": \"...\", \"reason\": \"...\", \"hook_event_name\": \"SessionEnd\"}\nHOOK_INPUT=$(cat)\n\n# Extract fields using jq (with fallback to grep/sed if jq not available)\nif command -v jq >/dev/null 2>&1; then\n    SESSION_ID=$(echo \"$HOOK_INPUT\" | jq -r '\\''.session_id // empty'\\'')\n    TRANSCRIPT_PATH=$(echo \"$HOOK_INPUT\" | jq -r '\\''.transcript_path // empty'\\'')\n    CWD=$(echo \"$HOOK_INPUT\" | jq -r '\\''.cwd // empty'\\'')\n    END_REASON=$(echo \"$HOOK_INPUT\" | jq -r '\\''.reason // \"unknown\"'\\'')\nelse\n    # Fallback: basic grep/sed parsing (less robust but works without jq)\n    SESSION_ID=$(echo \"$HOOK_INPUT\" | grep -o '\\''\"session_id\"[[:space:]]*:[[:space:]]*\"[^\"]*\"'\\'' | sed '\\''s/.*\"session_id\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/'\\'')\n    TRANSCRIPT_PATH=$(echo \"$HOOK_INPUT\" | grep -o '\\''\"transcript_path\"[[:space:]]*:[[:space:]]*\"[^\"]*\"'\\'' | sed '\\''s/.*\"transcript_path\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/'\\'')\n    CWD=$(echo \"$HOOK_INPUT\" | grep -o '\\''\"cwd\"[[:space:]]*:[[:space:]]*\"[^\"]*\"'\\'' | sed '\\''s/.*\"cwd\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/'\\'')\n    END_REASON=$(echo \"$HOOK_INPUT\" | grep -o '\\''\"reason\"[[:space:]]*:[[:space:]]*\"[^\"]*\"'\\'' | sed '\\''s/.*\"reason\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/'\\'')\n    [ -z \"$END_REASON\" ] && END_REASON=\"unknown\"\nfi\n\n# Use provided CWD or fallback to pwd\nif [ -z \"$CWD\" ]; then\n    CWD=$(pwd)\nfi\n\n# Get main repository root for registry lookup\n# Use git worktree list to get main worktree path (first worktree is always main)\n# This works correctly in both main repo and linked worktrees\nREPO_ROOT=$(git worktree list --porcelain 2>/dev/null | grep \"^worktree \" | head -1 | cut -d'\\'' '\\'' -f2)\n\n# If git worktree fails, try git rev-parse as fallback\nif [ -z \"$REPO_ROOT\" ]; then\n    REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)\nfi\n\n# If both git commands fail, fall back to resolving CWD canonically\nif [ -z \"$REPO_ROOT\" ]; then\n    if [ -d \"$CWD\" ]; then\n        REPO_ROOT=$(cd \"$CWD\" && pwd -P 2>/dev/null || echo \"$CWD\")\n    else\n        REPO_ROOT=$(pwd -P 2>/dev/null || pwd)\n    fi\nfi\n\n# Debug logging to help troubleshoot hook execution\necho \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] SessionEnd hook: CWD=$CWD, REPO_ROOT=$REPO_ROOT\" >> \"$HOOK_LOG\"\n\n# Expand ~ in transcript path if present\nTRANSCRIPT_PATH_EXPANDED=\"${TRANSCRIPT_PATH/#\\~/$HOME}\"\n\n# Copy transcript to backup location\nBACKUP_PATH=\"$TRANSCRIPTS_DIR/${SESSION_ID}.jsonl\"\n\nif [ -f \"$TRANSCRIPT_PATH_EXPANDED\" ]; then\n    cp \"$TRANSCRIPT_PATH_EXPANDED\" \"$BACKUP_PATH\" 2>/dev/null\n    if [ $? -eq 0 ]; then\n        # Set permissions to user-only read/write for security\n        chmod 600 \"$BACKUP_PATH\" 2>/dev/null\n    else\n        echo \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] Warning: Transcript copy failed: $TRANSCRIPT_PATH_EXPANDED\" >> \"$HOOK_LOG\"\n        # Continue anyway - event is still valuable even without transcript\n    fi\nelse\n    echo \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] Warning: Transcript not found: $TRANSCRIPT_PATH_EXPANDED\" >> \"$HOOK_LOG\"\n    # Continue anyway - event is still valuable even without transcript\nfi\n\n# Read connected repos registry to find repo_id\nREGISTRY_FILE=\"$HOME/.fuel/connected-repos.json\"\n\nif [ ! -f \"$REGISTRY_FILE\" ]; then\n    echo \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] Error: connected-repos.json not found at $REGISTRY_FILE\" >> \"$HOOK_LOG\"\n    exit 0\nfi\n\n# Find repo_id by matching repository root with repo_path in registry\nif command -v jq >/dev/null 2>&1; then\n    REPO_ID=$(jq -r --arg repo \"$REPO_ROOT\" '\\''.[] | select(.repo_path == $repo) | .id'\\'' \"$REGISTRY_FILE\")\nelse\n    # Fallback without jq (less robust)\n    # Note: In array format, id comes BEFORE repo_path, so we need to search differently\n    REPO_ID=$(grep -B5 \"\\\"repo_path\\\"[[:space:]]*:[[:space:]]*\\\"$REPO_ROOT\\\"\" \"$REGISTRY_FILE\" | grep '\\''\"id\"'\\'' | head -1 | sed '\\''s/.*\"id\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/'\\'')\nfi\n\nif [ -z \"$REPO_ID\" ] || [ \"$REPO_ID\" = \"null\" ]; then\n    echo \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] Warning: Repository not in connected repos: $REPO_ROOT\" >> \"$HOOK_LOG\"\n    exit 0\nfi\n\necho \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] Found repo_id: $REPO_ID for $REPO_ROOT\" >> \"$HOOK_LOG\"\n\n# Generate unique event filename with session_id for easy tracking\n# Format: claude_code_session_end_<timestamp>_<session_id>.json\nEVENT_FILE=\"$FUEL_EVENTS_NEW/claude_code_session_end_$(date +%s)_${SESSION_ID}.json\"\n\n# Write event file with BACKUP path (not original Claude Code path)\ncat > \"$EVENT_FILE\" <<EOF\n{\n  \"type\": \"claude_code_session_end\",\n  \"timestamp\": \"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\",\n  \"details\": {\n    \"session_id\": \"$SESSION_ID\",\n    \"transcript_path\": \"$BACKUP_PATH\",\n    \"cwd\": \"$CWD\",\n    \"end_reason\": \"$END_REASON\",\n    \"repo_id\": \"$REPO_ID\"\n  }\n}\nEOF\n\nif [ $? -ne 0 ]; then\n    echo \"[$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")] [FUEL] Error: Failed to write event file: $EVENT_FILE\" >> \"$HOOK_LOG\"\nfi\n\n# Always exit 0 to not block Claude Code\nexit 0\n'"
          }
        ]
      }
    ]
  }
}